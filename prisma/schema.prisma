generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

// ============================================================================
// Authentication & Users
// ============================================================================

model User {
  id            String    @id @default(cuid())
  email         String    @unique
  passwordHash  String
  name          String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  credentials   Credentials?
  strategies    Strategy[]
  orders        Order[]
  positions     Position[]
  auditLogs     AuditLog[]
  riskConfig    RiskConfig?
  sessions      Session[]
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Credentials {
  id                     String   @id @default(cuid())
  userId                 String   @unique
  encryptedPrivateKey    String?  // Encrypted with ENCRYPTION_KEY
  encryptedApiKey        String?
  encryptedApiSecret     String?
  encryptedPassphrase    String?
  walletAddress          String?
  isConnected            Boolean  @default(false)
  lastVerified           DateTime?
  createdAt              DateTime @default(now())
  updatedAt              DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================================================
// Risk Management
// ============================================================================

model RiskConfig {
  id                  String   @id @default(cuid())
  userId              String   @unique
  maxOrdersPerMinute  Int      @default(10)
  maxDailyLoss        Float    @default(1000)
  maxPositionSize     Float    @default(500)
  maxTotalExposure    Float    @default(5000)
  killSwitchActive    Boolean  @default(false)
  killSwitchReason    String?
  killSwitchActivatedAt DateTime?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

// ============================================================================
// Strategies
// ============================================================================

model Strategy {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  code        String   @db.Text
  version     Int      @default(1)
  isActive    Boolean  @default(false)
  
  // Configuration
  parameters  Json     @default("{}")  // JSON config for strategy
  marketIds   String[] @default([])    // Markets this strategy trades
  schedule    String?                  // Cron expression for scheduled runs
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  versions    StrategyVersion[]
  runs        StrategyRun[]
  orders      Order[]
}

model StrategyVersion {
  id          String   @id @default(cuid())
  strategyId  String
  version     Int
  code        String   @db.Text
  parameters  Json     @default("{}")
  changelog   String?
  createdAt   DateTime @default(now())

  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)

  @@unique([strategyId, version])
}

model StrategyRun {
  id          String          @id @default(cuid())
  strategyId  String
  mode        TradingMode
  status      RunStatus       @default(PENDING)
  trigger     RunTrigger      @default(MANUAL)
  
  // Execution details
  startedAt   DateTime?
  completedAt DateTime?
  duration    Int?            // milliseconds
  
  // Results
  logs        String?         @db.Text
  metrics     Json?           // { pnl, ordersPlaced, etc }
  error       String?
  
  createdAt   DateTime        @default(now())

  strategy Strategy @relation(fields: [strategyId], references: [id], onDelete: Cascade)
  orders   Order[]
}

enum RunStatus {
  PENDING
  RUNNING
  COMPLETED
  FAILED
  CANCELLED
}

enum RunTrigger {
  MANUAL
  CRON
  WEBHOOK
}

// ============================================================================
// Trading
// ============================================================================

model Order {
  id            String      @id @default(cuid())
  userId        String
  strategyId    String?
  strategyRunId String?
  
  // Market info
  marketId      String
  tokenId       String
  marketTitle   String?
  outcome       String?     // YES/NO
  
  // Order details
  side          OrderSide
  type          OrderType
  size          Float
  price         Float?      // For limit orders
  
  // Execution
  status        OrderStatus @default(PENDING)
  mode          TradingMode
  filledSize    Float       @default(0)
  filledPrice   Float?
  fees          Float       @default(0)
  slippage      Float?
  
  // Timestamps
  submittedAt   DateTime    @default(now())
  filledAt      DateTime?
  cancelledAt   DateTime?
  
  // External reference (for live orders)
  externalId    String?
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  user        User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  strategy    Strategy?    @relation(fields: [strategyId], references: [id], onDelete: SetNull)
  strategyRun StrategyRun? @relation(fields: [strategyRunId], references: [id], onDelete: SetNull)
}

model Position {
  id            String      @id @default(cuid())
  userId        String
  marketId      String
  tokenId       String
  marketTitle   String?
  outcome       String?
  mode          TradingMode
  
  // Position details
  size          Float
  avgEntryPrice Float
  currentPrice  Float?
  
  // PnL
  realizedPnl   Float       @default(0)
  unrealizedPnl Float       @default(0)
  
  // Timestamps
  openedAt      DateTime    @default(now())
  closedAt      DateTime?
  updatedAt     DateTime    @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, marketId, tokenId, mode])
}

enum TradingMode {
  PAPER
  LIVE
  SHADOW
}

enum OrderSide {
  BUY
  SELL
}

enum OrderType {
  MARKET
  LIMIT
  GTC     // Good Till Cancelled
  GTD     // Good Till Date
  FOK     // Fill or Kill
  FAK     // Fill and Kill
}

enum OrderStatus {
  PENDING
  OPEN
  PARTIALLY_FILLED
  FILLED
  CANCELLED
  FAILED
  EXPIRED
}

// ============================================================================
// Audit & Logging
// ============================================================================

model AuditLog {
  id        String   @id @default(cuid())
  userId    String
  action    String
  category  AuditCategory
  details   Json
  ipAddress String?
  userAgent String?
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([action])
  @@index([category])
}

enum AuditCategory {
  AUTH
  TRADING
  STRATEGY
  RISK
  SETTINGS
  SYSTEM
}

// ============================================================================
// Market Data Cache (optional, for performance)
// ============================================================================

model MarketCache {
  id            String   @id
  conditionId   String?
  slug          String?
  title         String
  description   String?  @db.Text
  outcomes      String[] @default([])
  outcomePrices Json?    // { YES: 0.65, NO: 0.35 }
  volume        Float?
  liquidity     Float?
  endDate       DateTime?
  closed        Boolean  @default(false)
  resolved      Boolean  @default(false)
  resolutionOutcome String?
  
  updatedAt     DateTime @updatedAt

  @@index([slug])
}
